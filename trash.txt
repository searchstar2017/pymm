enum INT_TYPE{
    IS_INT,
    IS_BIG
};

inline IsOverflow(int ans, int a, int b){
    return a < 0 && b < 0 && ans > 0 || a > 0 && b > 0 && ans < 0;
}

struct INTEGER{
    INT_TYPE type;
    void* val;
    INTEGER operator + (const INTEGER& rhs) const {
        static INTEGER ans;
        switch (type) {
        case IS_INT:
            switch (rhs.type) {
            case IS_INT:
                ans.val = new int;
                *(int*)ans.val = *(int*)val + *(int*)rhs.val;
                if(IsOverflow(*(int*)ans.val, *(int*)val, *(int*)rhs.val)){
                    ans.type = IS_BIG;
                    delete ans.val;
                    ans.val = new BigInt;
                    *(BigInt)ans.val = *(int*)val;
                    *(BigInt)ans.val += *(int*)rhs.val;
                }else{
                    ans.type = IS_INT;
                }
            case IS_BIG:
                ans.val = new BigInt;
                *(BitInt*)ans.val = *(BigInt*)rhs.val;
                *(BigInt*)ans.val += *(int*)val;
            }
        case IS_BIG:
            ans.val = BigInt;
            ans.val = new BigInt;
            switch (rhs.type) {
            case IS_INT:
                
            }
        }
        return ans;
    }
};







VARIABLE ALU(const IntType& lhs, const IntType& rhs, OP)
{
	static VARIABLE ans;
	ans.type = IS_INTEGER;
	ans.val = new IntType;
	*ans.val = lhs * rhs;
	return ans;
}












bool Parsing(NODE*& root, vector<StrExpr>::const_iterator now, string& information){
        stack<OPERAND_OR_OPERATOR>sta;
        static CONST_OR_VARIABLE operand;

        if(now->type == IS_NIL){
            root = NULL;
            return true;
        } else {
            switch (now->type){
            case IS_CONSTANT:
                operand.vari = false;
                GetConst(operand.val, now->name.c_str());
                sta.push(operand);
                break;
            case IS_OPERATOR:
                if (now->name == ")") {
                    root = NULL;

                } else if (now->name == "(") {

                }
            }
        }
    }











NODE(){}
    NODE(NodeType _type)
    {
        type = _type;
        switch (type) {
        case IS_CONSTANT:
        case IS_VARIABLE:
            val.val.val = NULL;
            break;
        }
    }
    ~NODE()
    {
        switch (type) {
        case IS_CONSTANT:
        case IS_VARIABLE:
            if (val.left_value) {
                delete val.val.val;
            }
            break;
        }
    }










size_t position(const vector<size_t>& pos) const {
		assert(len.size() == pos.size());
		size_t ans = 0;
		for (int i = 0; i < pos.size(); ++i) {
			ans += pos[i] * len[len.size() - i - 1];
		}
		return ans;
	}


void resize(const vector<size_t>& _len) {
		len.resize(_len.size());
		for (int i = 0; i < _len.size(); ++i) {
			len[len.size() - i - 1] = _len[i];
		}
		ResizeBase();
	}













VALUE operator <= (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(IntType*)val <= *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (double)*(IntType*)val <= *(double*)rhs.val;
				break;
			case IS_BOOL:
				assert(1);
				break;
			case IS_FRACTION:
				*(bool*)ans.val = *(IntType*)val <= *(FRACTION*)rhs.val;
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(double*)val <= (double)*(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = *(double*)val <= *(double*)rhs.val;
				break;
			case IS_BOOL:
				assert(1);
				break;
			case IS_FRACTION:
				*(bool*)ans.val = *(double*)val <= (double)*(FRACTION*)rhs.val;
				break;
			}
			break;
		case IS_BOOL:
			assert(1);
			break;
		case IS_FRACTION:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(FRACTION*)val <= *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (double)*(FRACTION*)val <= *(double*)rhs.val;
				break;
			case IS_BOOL:
				*(bool*)ans.val = *(FRACTION*)val <= (IntType)(int)*(bool*)rhs.val;
				break;
			case IS_FRACTION:
				*(bool*)ans.val = *(FRACTION*)val <= *(FRACTION*)rhs.val;
				break;
			}
			break;
		}
		return ans;
	}
VALUE operator > (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(IntType*)val > *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (double)*(IntType*)val > *(double*)rhs.val;
				break;
			case IS_BOOL:
				assert(1);
				break;
			case IS_FRACTION:
				*(bool*)ans.val = *(IntType*)val > *(FRACTION*)rhs.val;
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(double*)val > (double)*(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = *(double*)val > *(double*)rhs.val;
				break;
			case IS_BOOL:
				assert(1);
				break;
			case IS_FRACTION:
				*(bool*)ans.val = *(double*)val > (double)*(FRACTION*)rhs.val;
				break;
			}
			break;
		case IS_BOOL:
			assert(1);
			break;
		case IS_FRACTION:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(FRACTION*)val >= *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (double)*(FRACTION*)val >= *(double*)rhs.val;
				break;
			case IS_BOOL:
				*(bool*)ans.val = *(FRACTION*)val >= (IntType)(int)*(bool*)rhs.val;
				break;
			case IS_FRACTION:
				*(bool*)ans.val = *(FRACTION*)val >= *(FRACTION*)rhs.val;
				break;
			}
			break;
		}
		return ans;
	}
	VALUE operator >= (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(IntType*)val >= *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (double)*(IntType*)val >= *(double*)rhs.val;
				break;
			case IS_BOOL:
				assert(1);
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(double*)val >= (double)*(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = *(double*)val >= *(double*)rhs.val;
				break;
			case IS_BOOL:
				assert(1);
				break;
			}
			break;
		case IS_BOOL:
			assert(1);
			break;
		}
		return ans;
	}
	VALUE operator == (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(IntType*)val == *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = Equal((double)*(IntType*)val, *(double*)rhs.val);
				break;
			case IS_BOOL:
				*(bool*)ans.val = *(IntType*)val == (IntType)(int)*(bool*)rhs.val;
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = Equal(*(double*)val, (double)*(IntType*)rhs.val);
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = Equal(*(double*)val, *(double*)rhs.val);
				break;
			case IS_BOOL:
				*(bool*)ans.val = Equal(*(double*)val, (double)(int)*(bool*)rhs.val);
				break;
			}
			break;
		case IS_BOOL:
			switch (rhs.type) {
            case IS_INTEGER:
                *(bool*)ans.val = *(bool*)val == (bool)*(IntType*)rhs.val;
                break;
            case IS_DOUBLE:
                *(bool*)ans.val = *(bool*)val == (bool)*(double*)rhs.val;
                break;
            case IS_BOOL:
                *(bool*)ans.val = *(bool*)val == *(bool*)rhs.val;
                break;
			}
			break;
		}
		return ans;
	}
	VALUE operator != (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(IntType*)val != *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = NotEqual((double)*(IntType*)val, *(double*)rhs.val);
				break;
			case IS_BOOL:
				assert(1);
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = NotEqual(*(double*)val, (double)*(IntType*)rhs.val);
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = NotEqual(*(double*)val, *(double*)rhs.val);
				break;
			case IS_BOOL:
				assert(1);
				break;
			}
			break;
		case IS_BOOL:
			assert(1);
			break;
		}
		return ans;
	}


    





VALUE operator && (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = (bool)*(IntType*)val && (bool)*(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (bool)*(IntType*)val && *(bool*)rhs.val;
				break;
			case IS_BOOL:
				*(bool*)ans.val = (bool)*(IntType*)val && *(bool*)rhs.val;
				break;
			case IS_FRACTION:
				*(bool*)ans.val = (bool)*(IntType*)val && (bool)*(FRACTION*)rhs.val;
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = NotZero(*(double*)val) && (bool)*(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = NotZero(*(double*)val) && NotZero(*(double*)rhs.val);
				break;
			case IS_BOOL:
				*(bool*)ans.val = (bool)*(double*)val && *(bool*)rhs.val;
				break;
			}
			break;
		case IS_BOOL:
			switch (rhs.type) {
            case IS_INTEGER:
                *(bool*)ans.val = *(bool*)val && (bool)*(IntType*)rhs.val;
                break;
            case IS_DOUBLE:
                *(bool*)ans.val = *(bool*)val && NotZero(*(double*)rhs.val);
                break;
            case IS_BOOL:
                *(bool*)ans.val = *(bool*)val && *(bool*)rhs.val;
                break;
			}
			break;
		}
		return ans;
	}
	VALUE operator || (const VALUE& rhs) {
		static VALUE ans;
		ans.type = IS_BOOL;
		ans.val = new bool;
		switch (type) {
		case IS_INTEGER:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(IntType*)val || *(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = (double)*(IntType*)val || *(double*)rhs.val;
				break;
			case IS_BOOL:
				*(bool*)ans.val = (bool)*(IntType*)val || *(bool*)rhs.val;
				break;
			}
			break;
		case IS_DOUBLE:
			switch (rhs.type) {
			case IS_INTEGER:
				*(bool*)ans.val = *(double*)val || (double)*(IntType*)rhs.val;
				break;
			case IS_DOUBLE:
				*(bool*)ans.val = *(double*)val || *(double*)rhs.val;
				break;
			case IS_BOOL:
				*(bool*)ans.val = NotZero(*(double*)val) || *(bool*)rhs.val;
				break;
			}
			break;
		case IS_BOOL:
			switch (rhs.type) {
            case IS_INTEGER:
                *(bool*)ans.val = (bool)*(IntType*)val || *(bool*)rhs.val;
                break;
            case IS_DOUBLE:
                *(bool*)ans.val = *(bool*)val || NotZero(*(double*)rhs.val);
                break;
            case IS_BOOL:
                *(bool*)ans.val = *(bool*)val || *(bool*)rhs.val;
                break;
			}
			break;
		}
		return ans;
	}



VARIABLE operator && (const VARIABLE& rhs) const {
		assert(type == IS_VALUE && rhs.type == IS_VALUE);
        return VARIABLE(*(VALUE*)val && *(VALUE*)rhs.val);
    }
    VARIABLE operator || (const VARIABLE& rhs) const {
		assert(type == IS_VALUE && rhs.type == IS_VALUE);
        return VARIABLE(*(VALUE*)val || *(VALUE*)rhs.val);
    }



CONST_OR_VARIABLE operator && (const CONST_OR_VARIABLE& rhs) const {
		static CONST_OR_VARIABLE ans;
		ans.Init_new(false, false);
		*ans.val = *val && *rhs.val;
		return ans;
    }
    CONST_OR_VARIABLE operator || (const CONST_OR_VARIABLE& rhs) const {
		static CONST_OR_VARIABLE ans;
		ans.Init_new(false, false);
		*ans.val = *val || *rhs.val;
		return ans;
	}


